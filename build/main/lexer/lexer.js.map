{"version":3,"sources":["../../../src/main/lexer/lexer.js"],"names":["Lexer","input","position","line","column","tokens","token","nextToken","type","TokenType","EndOfInput","push","length","Token","skipWhitespacesAndNewLines","character","charAt","CharUtils","isLetter","recognizeIdentifier","isDigit","recognizeNumber","isOperator","recognizeOperator","isParenthesis","recognizeParenthesis","Error","isWhitespaceOrNewLine","isNewLine","identifier","Identifier","fsm","buildNumberRecognizer","fsmInput","substring","run","isNumberRecognized","number","Number","State","Initial","Integer","BeginNumberWithFractionalPart","NumberWithFractionalPart","BeginNumberWithExponent","BeginNumberWithSignedExponent","NumberWithExponent","NoNextState","FSM","states","Set","initialState","acceptingStates","nextState","currentState","toLowerCase","isComparisonOperator","recognizeComparisonOperator","isArithmeticOperator","operator","recognizeArithmeticOperator","lookahead","isLookaheadEqualSymbol","GreaterThanOrEqual","GreaterThan","LessThanOrEqual","LessThan","Equal","Assign","Plus","Minus","Times","Div","LeftParenthesis","RightParenthesis"],"mappings":"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","file":"lexer.js","sourcesContent":["import { Token } from './token'\nimport { TokenType } from './tokentype'\n\nexport class Lexer {\n    constructor(input) {\n        this.input = input;\n        this.position = 0;\n        this.line = 0;\n        this.column = 0;\n    }\n\n    tokenize() {\n        let tokens = [];\n        let token = this.nextToken();\n\n        while (token.type !== TokenType.EndOfInput) {\n            tokens.push(token);\n            token = this.nextToken();\n        }\n\n        return tokens;\n    }\n\n    nextToken() {\n        // TODO: Write your code here. :)\n        if (this.position >= this.input.length)\n        {\n          return new Token(TokenType.EndOfInput);\n        }\n\n        this.skipWhitespacesAndNewLines();\n\n        let character = this.input.charAt(this.position);\n\n        if (CharUtils.isLetter(character)){\n          return this.recognizeIdentifier();\n        }\n\n        if (CharUtils.isDigit(character)){\n          return this.recognizeNumber();\n        }\n\n        if (CharUtils.isOperator(character)){\n          return this.recognizeOperator();\n        }\n\n        if (CharUtils.isParenthesis(character)) {\n           return this.recognizeParenthesis();\n       }\n\n       // Throw an error if the current character does not match\n       // any production rule of the lexical grammar.\n       throw new Error('Unrecognized character ${character} at line ${this.line} and column ${this.column}.');\n    }\n    skipWhitespacesAndNewLines() {\n      while (this.position < this.input.length && CharUtils.isWhitespaceOrNewLine(this.input.charAt(this.position))) {\n        this.position += 1;\n\n        if (CharUtils.isNewLine(this.input.charAt(this.position))) {\n            this.line += 1;\n            this.column = 0;\n        } else {\n          this.column += 1;\n        }\n\n      }\n    }\n\n    /// Recognizes and returns an identifier token.\n   recognizeIdentifier() {\n     let identifier = '';\n     let line = this.line;\n     let column = this.column;\n     let position = this.position;\n\n     while (position < this.input.length) {\n         let character = this.input.charAt(position);\n\n         if (!(CharUtils.isLetter(character) || CharUtils.isDigit(character) || character === '-')) {\n           break;\n         }\n\n         identifier += character;\n         position += 1;\n     }\n\n     this.position += identifier.length;\n     this.column += identifier.length;\n\n     return new Token(TokenType.Identifier, identifier, line, column);\n }\n\n   /// Recognizes and returns a number token.\n   /// Recognizes and returns a number token.\n recognizeNumber() {\n     let line = this.line;\n     let column = this.column;\n\n     // We delegate the building of the FSM to a helper method.\n     let fsm = this.buildNumberRecognizer();\n\n     // The input to the FSM will be all the characters from\n     // the current position to the rest of the lexer's input.\n     let fsmInput = this.input.substring(this.position);\n\n     // Here, in addition of the FSM returning whether a number\n     // has been recognized or not, it also returns the number\n     // recognized in the 'number' variable. If no number has\n     // been recognized, 'number' will be 'null'.\n     let { isNumberRecognized, number } = fsm.run(fsmInput);\n\n     if (isNumberRecognized) {\n         this.position += number.length;\n         this.column += number.length;\n\n         return new Token(TokenType.Number, number, line, column);\n     }\n\n     // ...\n }\n\n buildNumberRecognizer() {\n     // We name our states for readability.\n     let State = {\n         Initial: 1,\n         Integer: 2,\n         BeginNumberWithFractionalPart: 3,\n         NumberWithFractionalPart: 4,\n         BeginNumberWithExponent: 5,\n         BeginNumberWithSignedExponent: 6,\n         NumberWithExponent: 7,\n         NoNextState: -1\n     };\n\n     let fsm = new FSM()\n     fsm.states = new Set([State.Initial, State.Integer, State.BeginNumberWithFractionalPart, State.NumberWithFractionalPart, /* ... */]);\n     fsm.initialState = State.Initial;\n     fsm.acceptingStates = new Set([State.Integer, State.NumberWithFractionalPart, State.NumberWithExponent]);\n     fsm.nextState = (currentState, character) => {\n         switch (currentState) {\n             case State.Initial:\n                 if (CharUtils.isDigit(character)) {\n                     return State.Integer;\n                 }\n\n                 break;\n\n             case State.Integer:\n                 if (CharUtils.isDigit(character)) {\n                     return State.Integer;\n                 }\n\n                 if (character === '.') {\n                     return State.BeginNumberWithFractionalPart;\n                 }\n\n                 if (character.toLowerCase() === 'e') {\n                     return State.BeginNumberWithExponent;\n                 }\n\n                 break;\n\n             case State.BeginNumberWithFractionalPart:\n                 if (CharUtils.isDigit(character)) {\n                     return State.NumberWithFractionalPart;\n                 }\n\n                 break;\n\n             case State.NumberWithFractionalPart:\n                 if (CharUtils.isDigit(character)) {\n                     return State.NumberWithFractionalPart;\n                 }\n\n                 if (character.toLowerCase() === 'e') {\n                     return State.BeginNumberWithExponent;\n                 }\n\n                 break;\n\n             case State.BeginNumberWithExponent:\n                 if (character === '+' || character === '-'){\n                     return State.BeginNumberWithSignedExponent;\n                 }\n\n                 if (CharUtils.isDigit()) {\n                     return State.NumberWithExponent;\n                 }\n\n                 break;\n\n             case State.BeginNumberWithSignedExponent:\n                 if (CharUtils.isDigit()) {\n                     return State.NumberWithExponent;\n                 }\n\n                 break;\n\n             default:\n                 break;\n         }\n\n         return State.NoNextState;\n     };\n\n     return fsm;\n }\n\n   /// Recognizes and returns an operator token.\n   recognizeOperator() {\n   let character = this.input.charAt(this.position);\n\n   if (CharUtils.isComparisonOperator(character)) {\n       return recognizeComparisonOperator();\n   }\n\n   if (CharUtils.isArithmeticOperator(operator)) {\n       return recognizeArithmeticOperator();\n   }\n\n   // ...\n}\n\nrecognizeComparisonOperator() {\n   let position = this.position;\n   let line = this.line;\n   let column = this.column;\n   let character = this.input.charAt(position);\n\n   // 'lookahead' is the next character in the input\n   // or 'null' if 'character' was the last character.\n   let lookahead = position + 1 < this.input.length ? this.input.charAt(position + 1) : null;\n\n   // Whether the 'lookahead' character is the equal symbol '='.\n   let isLookaheadEqualSymbol = lookahead !== null && lookahead === '=';\n\n   this.position += 1;\n   this.column += 1;\n\n   if (isLookaheadEqualSymbol) {\n       this.position += 1;\n       this.column += 1;\n   }\n\n   switch (character) {\n       case '>':\n           return isLookaheadEqualSymbol\n               ? new Token(TokenType.GreaterThanOrEqual, '>=', line, column)\n               : new Token(TokenType.GreaterThan, '>', line, column);\n\n       case '<':\n           return isLookaheadEqualSymbol\n               ? new Token(TokenType.LessThanOrEqual, '<=', line, column)\n               : new Token(TokenType.LessThan, '<', line, column);\n\n       case '=':\n           return isLookaheadEqualSymbol\n               ? new Token(TokenType.Equal, '==', line, column)\n               : new Token(TokenType.Assign, '=', line, column);\n\n       default:\n           break;\n   }\n\n   // ...\n}\n\nrecognizeArithmeticOperator() {\n   let position = this.position;\n   let line = this.line;\n   let column = this.column;\n   let character = this.input.charAt(position);\n\n   this.position += 1;\n   this.column += 1;\n\n   switch (character) {\n       case '+':\n           return new Token(TokenType.Plus, '+', line, column);\n\n       case '-':\n           return new Token(TokenType.Minus, '-', line, column);\n\n       case '*':\n           return new Token(TokenType.Times, '*', line, column);\n\n       case '/':\n           return new Token(TokenType.Div, '/', line, column);\n   }\n\n   // ...\n}\n\n\n   /// Recognizes and returns a parenthesis token.\n   recognizeParenthesis() {\n       /// Recognizes and returns a parenthesis token.\n     let position = this.position;\n     let line = this.line;\n     let column = this.column;\n     let character = this.input.charAt(position);\n\n     this.position += 1;\n     this.column += 1;\n\n     if (character === '(') {\n         return new Token(TokenType.LeftParenthesis, '(', line, column);\n     }\n\n     return new Token(TokenType.RightParenthesis, ')', line, column);\n\n   }\n}\n"]}